import {After, Before, ITestCaseHookParameter, Status,} from "@cucumber/cucumber";
import {CustomWorld} from "./world";
import {AllureGroup, AllureRuntime, AllureTest, ContentType, Status as AllureStatus,} from "allure-js-commons";
import * as fs from "node:fs";

const allureResultsDir = process.env.ALLURE_RESULTS_DIR || "./allure-results";

// Ensure the directory exists
if (!fs.existsSync(allureResultsDir)) {
  fs.mkdirSync(allureResultsDir, {recursive: true});
}

console.log(`✅ Using Allure results directory: ${allureResultsDir}`);

const allureRuntime = new AllureRuntime({
  resultsDir: allureResultsDir,
});

let allureGroup: AllureGroup | null = null;
let allureTest: AllureTest | null = null;

Before(async function (this: CustomWorld, scenario: ITestCaseHookParameter) {
  if (!process.env.BROWSER) {
    console.error(
        "⚠️ BROWSER environment variable is not set. Defaulting to 'chromium'.",
    );
  }
  const browserType = process.env.BROWSER || "chromium";
  console.log(`Running test on browser: ${browserType}`);
  const env = process.env.TEST_ENV || "testdev1";

  // Convert environment alias
  const envAlias = env === "testdev1" ? "td1" : "td2";
  const formattedBrowser =
      browserType.charAt(0).toUpperCase() + browserType.slice(1);

  // Modify scenario name before execution
  const testName = `${scenario.pickle.name} (${formattedBrowser}-${envAlias})`;
  console.log(`Starting test: ${testName}`);

  this.testName = testName;

  // ✅ Assign Allure Group and Test only once
  allureGroup = allureRuntime.startGroup("QA Alchemist Suite");
  allureTest = allureGroup.startTest(testName);
  allureTest.addLabel("feature", "QA Alchemist");
  allureTest.addLabel("browser", browserType);
  allureTest.addLabel("environment", env);
  allureTest.addLabel("testName", testName);
  allureTest.addLabel("framework", "CucumberJS");
  console.log(`✅ Running test with browser: ${browserType}`);

  this.testName = testName;
  await this.setup();
});

After(async function (this: CustomWorld, scenario) {
  const timestamp = new Date().toISOString().replace(/[:.]/g, "-");
  const browserType = process.env.BROWSER || "chromium";
  let isFailed = false;
  const env = process.env.TEST_ENV || "testdev1";
  const envAlias = env === "testdev1" ? "td1" : "td2";

  try {
    if (!this.testName) {
      this.testName = scenario.pickle.name;
    }

    const testName = this.testName;
    console.log(`Finalizing test: ${testName}`);

    if (!allureTest) {
      console.error("Allure test instance is undefined!");
      return;
    }

    // Attach Screenshot for Failed Tests
    if (scenario.result?.status === Status.FAILED) {
      isFailed = true;
      const screenshot = await this.page?.screenshot({
        path: `test-results/screenshots/${browserType}_${envAlias}_${scenario.pickle.name}_${timestamp}.png`,
        fullPage: true,
      });

      if (screenshot) {
        console.log("Attaching screenshot for failed test...");
        await this.attach(screenshot, "image/png");

        const screenshotAttachmentPath = allureRuntime.writeAttachment(
          screenshot,
          {
            contentType: ContentType.PNG,
            fileExtension: "png",
          },
        );
        allureTest.addAttachment(
          "Screenshot",
          ContentType.PNG,
          screenshotAttachmentPath,
        );
        console.log("Screenshot attached to Allure.");
      }

      // Attach Video
      const video = this.page?.video();
      const videoPath = await video?.path();
      if (isFailed && videoPath) {
        console.log("Attaching video for failed test...");
        const videoBuffer = await fs.promises.readFile(videoPath);
        const videoAttachmentPath = allureRuntime.writeAttachment(videoBuffer, {
          contentType: ContentType.WEBM,
          fileExtension: "webm",
        });
        allureTest.addAttachment(
          "Test Video",
          "video/webm",
          videoAttachmentPath,
        );
        await this.page?.waitForTimeout(2000);
        console.log(`Video attached to Allure: ${videoAttachmentPath}`);
      }
    }

    allureTest.name = this.testName;

    // ✅ Ensure Allure Test Status is Set
    allureTest.status =
        scenario.result?.status === Status.PASSED
        ? AllureStatus.PASSED
        : AllureStatus.FAILED;

    // ✅ Ensure Allure Group and Test Are Properly Ended
    if (allureTest) {
      allureTest.endTest();
    }
    if (allureGroup) {
      allureGroup.endGroup();
    }

    // Now do the teardown
    await this.teardown(isFailed);
    
    // If we're running a test generated by the AI, force process exit
    // This is needed because some Playwright processes may hang
    if (process.env.AI_GENERATED_TEST === 'true') {
      console.log('AI-generated test complete, forcing clean exit');
      setTimeout(() => {
        process.exit(scenario.result?.status === Status.PASSED ? 0 : 1);
      }, 500);
    }
    
  } catch (error) {
    console.error("Error in After hook:", error);

    // Ensure Allure Test is properly ended even on error
    if (allureTest) {
      allureTest.status = AllureStatus.BROKEN;
      allureTest.endTest();
    }
    if (allureGroup) {
      allureGroup.endGroup();
    }

    // Attempt browser cleanup
    try {
      await this.teardown(true);
    } catch (teardownError) {
      console.error("Error during teardown:", teardownError);
    }
    
    // Force exit on error
    if (process.env.AI_GENERATED_TEST === 'true') {
      console.log('Error in AI-generated test, forcing exit');
      setTimeout(() => process.exit(1), 500);
    }
  }
});
